\doxysection{nlohmann\+::detail Namespace Reference}
\label{namespacenlohmann_1_1detail}\index{nlohmann::detail@{nlohmann::detail}}


detail namespace with internal helper functions  


\doxysubsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
namespace \textbf{ dtoa\+\_\+impl}
\begin{DoxyCompactList}\small\item\em implements the Grisu2 algorithm for binary to decimal floating-\/point conversion. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \textbf{ binary\+\_\+reader}
\begin{DoxyCompactList}\small\item\em deserialization of CBOR, Message\+Pack, and UBJSON values \end{DoxyCompactList}\item 
class \textbf{ binary\+\_\+writer}
\begin{DoxyCompactList}\small\item\em serialization to CBOR and Message\+Pack values \end{DoxyCompactList}\item 
struct \textbf{ conjunction}
\item 
struct \textbf{ conjunction$<$ B1 $>$}
\item 
struct \textbf{ conjunction$<$ B1, Bn... $>$}
\item 
struct \textbf{ detector}
\item 
struct \textbf{ detector$<$ Default, void\+\_\+t$<$ Op$<$ Args... $>$ $>$, Op, Args... $>$}
\item 
class \textbf{ exception}
\begin{DoxyCompactList}\small\item\em general exception of the \doxyref{basic\+\_\+json}{p.}{classnlohmann_1_1basic__json} class \end{DoxyCompactList}\item 
struct \textbf{ external\+\_\+constructor}
\item 
struct \textbf{ external\+\_\+constructor$<$ value\+\_\+t\+::array $>$}
\item 
struct \textbf{ external\+\_\+constructor$<$ value\+\_\+t\+::binary $>$}
\item 
struct \textbf{ external\+\_\+constructor$<$ value\+\_\+t\+::boolean $>$}
\item 
struct \textbf{ external\+\_\+constructor$<$ value\+\_\+t\+::number\+\_\+float $>$}
\item 
struct \textbf{ external\+\_\+constructor$<$ value\+\_\+t\+::number\+\_\+integer $>$}
\item 
struct \textbf{ external\+\_\+constructor$<$ value\+\_\+t\+::number\+\_\+unsigned $>$}
\item 
struct \textbf{ external\+\_\+constructor$<$ value\+\_\+t\+::object $>$}
\item 
struct \textbf{ external\+\_\+constructor$<$ value\+\_\+t\+::string $>$}
\item 
class \textbf{ file\+\_\+input\+\_\+adapter}
\item 
struct \textbf{ from\+\_\+json\+\_\+fn}
\item 
struct \textbf{ has\+\_\+from\+\_\+json}
\item 
struct \textbf{ has\+\_\+from\+\_\+json$<$ Basic\+Json\+Type, T, enable\+\_\+if\+\_\+t$<$ !is\+\_\+basic\+\_\+json$<$ T $>$\+::value $>$ $>$}
\item 
struct \textbf{ has\+\_\+non\+\_\+default\+\_\+from\+\_\+json}
\item 
struct \textbf{ has\+\_\+non\+\_\+default\+\_\+from\+\_\+json$<$ Basic\+Json\+Type, T, enable\+\_\+if\+\_\+t$<$ !is\+\_\+basic\+\_\+json$<$ T $>$\+::value $>$ $>$}
\item 
struct \textbf{ has\+\_\+to\+\_\+json}
\item 
struct \textbf{ has\+\_\+to\+\_\+json$<$ Basic\+Json\+Type, T, enable\+\_\+if\+\_\+t$<$ !is\+\_\+basic\+\_\+json$<$ T $>$\+::value $>$ $>$}
\item 
struct \textbf{ index\+\_\+sequence}
\item 
class \textbf{ input\+\_\+stream\+\_\+adapter}
\item 
struct \textbf{ internal\+\_\+iterator}
\begin{DoxyCompactList}\small\item\em an iterator value \end{DoxyCompactList}\item 
class \textbf{ invalid\+\_\+iterator}
\begin{DoxyCompactList}\small\item\em exception indicating errors with iterators \end{DoxyCompactList}\item 
struct \textbf{ is\+\_\+basic\+\_\+json}
\item 
struct \textbf{ is\+\_\+basic\+\_\+json$<$ NLOHMANN\+\_\+\+BASIC\+\_\+\+JSON\+\_\+\+TPL $>$}
\item 
struct \textbf{ is\+\_\+compatible\+\_\+array\+\_\+type}
\item 
struct \textbf{ is\+\_\+compatible\+\_\+array\+\_\+type\+\_\+impl}
\item 
struct \textbf{ is\+\_\+compatible\+\_\+array\+\_\+type\+\_\+impl$<$ Basic\+Json\+Type, Compatible\+Array\+Type, enable\+\_\+if\+\_\+t$<$ is\+\_\+detected$<$ value\+\_\+type\+\_\+t, Compatible\+Array\+Type $>$\+::value \&\&is\+\_\+detected$<$ iterator\+\_\+t, Compatible\+Array\+Type $>$\+::value \&\&!is\+\_\+iterator\+\_\+traits$<$ iterator\+\_\+traits$<$ Compatible\+Array\+Type $>$ $>$\+::value $>$ $>$}
\item 
struct \textbf{ is\+\_\+compatible\+\_\+integer\+\_\+type}
\item 
struct \textbf{ is\+\_\+compatible\+\_\+integer\+\_\+type\+\_\+impl}
\item 
struct \textbf{ is\+\_\+compatible\+\_\+integer\+\_\+type\+\_\+impl$<$ Real\+Integer\+Type, Compatible\+Number\+Integer\+Type, enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+integral$<$ Real\+Integer\+Type $>$\+::value \&\&std\+::is\+\_\+integral$<$ Compatible\+Number\+Integer\+Type $>$\+::value \&\&!std\+::is\+\_\+same$<$ bool, Compatible\+Number\+Integer\+Type $>$\+::value $>$ $>$}
\item 
struct \textbf{ is\+\_\+compatible\+\_\+object\+\_\+type}
\item 
struct \textbf{ is\+\_\+compatible\+\_\+object\+\_\+type\+\_\+impl}
\item 
struct \textbf{ is\+\_\+compatible\+\_\+object\+\_\+type\+\_\+impl$<$ Basic\+Json\+Type, Compatible\+Object\+Type, enable\+\_\+if\+\_\+t$<$ is\+\_\+detected$<$ mapped\+\_\+type\+\_\+t, Compatible\+Object\+Type $>$\+::value \&\&is\+\_\+detected$<$ key\+\_\+type\+\_\+t, Compatible\+Object\+Type $>$\+::value $>$ $>$}
\item 
struct \textbf{ is\+\_\+compatible\+\_\+string\+\_\+type}
\item 
struct \textbf{ is\+\_\+compatible\+\_\+string\+\_\+type\+\_\+impl}
\item 
struct \textbf{ is\+\_\+compatible\+\_\+string\+\_\+type\+\_\+impl$<$ Basic\+Json\+Type, Compatible\+String\+Type, enable\+\_\+if\+\_\+t$<$ is\+\_\+detected\+\_\+exact$<$ typename Basic\+Json\+Type\+::string\+\_\+t\+::value\+\_\+type, value\+\_\+type\+\_\+t, Compatible\+String\+Type $>$\+::value $>$ $>$}
\item 
struct \textbf{ is\+\_\+compatible\+\_\+type}
\item 
struct \textbf{ is\+\_\+compatible\+\_\+type\+\_\+impl}
\item 
struct \textbf{ is\+\_\+compatible\+\_\+type\+\_\+impl$<$ Basic\+Json\+Type, Compatible\+Type, enable\+\_\+if\+\_\+t$<$ is\+\_\+complete\+\_\+type$<$ Compatible\+Type $>$\+::value $>$ $>$}
\item 
struct \textbf{ is\+\_\+complete\+\_\+type}
\item 
struct \textbf{ is\+\_\+complete\+\_\+type$<$ T, decltype(void(sizeof(\+T)))$>$}
\item 
struct \textbf{ is\+\_\+constructible\+\_\+array\+\_\+type}
\item 
struct \textbf{ is\+\_\+constructible\+\_\+array\+\_\+type\+\_\+impl}
\item 
struct \textbf{ is\+\_\+constructible\+\_\+array\+\_\+type\+\_\+impl$<$ Basic\+Json\+Type, Constructible\+Array\+Type, enable\+\_\+if\+\_\+t$<$ !std\+::is\+\_\+same$<$ Constructible\+Array\+Type, typename Basic\+Json\+Type\+::value\+\_\+type $>$\+::value \&\&std\+::is\+\_\+default\+\_\+constructible$<$ Constructible\+Array\+Type $>$\+::value \&\&(std\+::is\+\_\+move\+\_\+assignable$<$ Constructible\+Array\+Type $>$\+::value$\vert$$\vert$std\+::is\+\_\+copy\+\_\+assignable$<$ Constructible\+Array\+Type $>$\+::value)\&\&is\+\_\+detected$<$ value\+\_\+type\+\_\+t, Constructible\+Array\+Type $>$\+::value \&\&is\+\_\+detected$<$ iterator\+\_\+t, Constructible\+Array\+Type $>$\+::value \&\&is\+\_\+complete\+\_\+type$<$ detected\+\_\+t$<$ value\+\_\+type\+\_\+t, Constructible\+Array\+Type $>$ $>$\+::value $>$ $>$}
\item 
struct \textbf{ is\+\_\+constructible\+\_\+array\+\_\+type\+\_\+impl$<$ Basic\+Json\+Type, Constructible\+Array\+Type, enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+same$<$ Constructible\+Array\+Type, typename Basic\+Json\+Type\+::value\+\_\+type $>$\+::value $>$ $>$}
\item 
struct \textbf{ is\+\_\+constructible\+\_\+object\+\_\+type}
\item 
struct \textbf{ is\+\_\+constructible\+\_\+object\+\_\+type\+\_\+impl}
\item 
struct \textbf{ is\+\_\+constructible\+\_\+object\+\_\+type\+\_\+impl$<$ Basic\+Json\+Type, Constructible\+Object\+Type, enable\+\_\+if\+\_\+t$<$ is\+\_\+detected$<$ mapped\+\_\+type\+\_\+t, Constructible\+Object\+Type $>$\+::value \&\&is\+\_\+detected$<$ key\+\_\+type\+\_\+t, Constructible\+Object\+Type $>$\+::value $>$ $>$}
\item 
struct \textbf{ is\+\_\+constructible\+\_\+string\+\_\+type}
\item 
struct \textbf{ is\+\_\+constructible\+\_\+string\+\_\+type\+\_\+impl}
\item 
struct \textbf{ is\+\_\+constructible\+\_\+string\+\_\+type\+\_\+impl$<$ Basic\+Json\+Type, Constructible\+String\+Type, enable\+\_\+if\+\_\+t$<$ is\+\_\+detected\+\_\+exact$<$ typename Basic\+Json\+Type\+::string\+\_\+t\+::value\+\_\+type, value\+\_\+type\+\_\+t, Constructible\+String\+Type $>$\+::value $>$ $>$}
\item 
struct \textbf{ is\+\_\+constructible\+\_\+tuple}
\item 
struct \textbf{ is\+\_\+constructible\+\_\+tuple$<$ T1, std\+::tuple$<$ Args... $>$ $>$}
\item 
struct \textbf{ is\+\_\+getable}
\item 
struct \textbf{ is\+\_\+iterator\+\_\+of\+\_\+multibyte}
\item 
struct \textbf{ is\+\_\+iterator\+\_\+traits}
\item 
struct \textbf{ is\+\_\+iterator\+\_\+traits$<$ iterator\+\_\+traits$<$ T $>$ $>$}
\item 
struct \textbf{ is\+\_\+json\+\_\+ref}
\item 
struct \textbf{ is\+\_\+json\+\_\+ref$<$ json\+\_\+ref$<$ T $>$ $>$}
\item 
struct \textbf{ is\+\_\+sax}
\item 
struct \textbf{ is\+\_\+sax\+\_\+static\+\_\+asserts}
\item 
class \textbf{ iter\+\_\+impl}
\begin{DoxyCompactList}\small\item\em a template for a bidirectional iterator for the \doxyref{basic\+\_\+json}{p.}{classnlohmann_1_1basic__json} class This class implements a both iterators (iterator and const\+\_\+iterator) for the \doxyref{basic\+\_\+json}{p.}{classnlohmann_1_1basic__json} class. \end{DoxyCompactList}\item 
class \textbf{ iteration\+\_\+proxy}
\begin{DoxyCompactList}\small\item\em proxy class for the items() function \end{DoxyCompactList}\item 
class \textbf{ iteration\+\_\+proxy\+\_\+value}
\item 
class \textbf{ iterator\+\_\+input\+\_\+adapter}
\item 
struct \textbf{ iterator\+\_\+input\+\_\+adapter\+\_\+factory}
\item 
struct \textbf{ iterator\+\_\+input\+\_\+adapter\+\_\+factory$<$ Iterator\+Type, enable\+\_\+if\+\_\+t$<$ is\+\_\+iterator\+\_\+of\+\_\+multibyte$<$ Iterator\+Type $>$\+::value $>$ $>$}
\item 
struct \textbf{ iterator\+\_\+traits}
\item 
struct \textbf{ iterator\+\_\+traits$<$ T $\ast$, enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+object$<$ T $>$\+::value $>$ $>$}
\item 
struct \textbf{ iterator\+\_\+traits$<$ T, enable\+\_\+if\+\_\+t$<$ !std\+::is\+\_\+pointer$<$ T $>$\+::value $>$ $>$}
\item 
struct \textbf{ iterator\+\_\+types}
\item 
struct \textbf{ iterator\+\_\+types$<$ It, void\+\_\+t$<$ typename It\+::difference\+\_\+type, typename It\+::value\+\_\+type, typename It\+::pointer, typename It\+::reference, typename It\+::iterator\+\_\+category $>$ $>$}
\item 
class \textbf{ json\+\_\+ref}
\item 
class \textbf{ json\+\_\+reverse\+\_\+iterator}
\begin{DoxyCompactList}\small\item\em a template for a reverse iterator class \end{DoxyCompactList}\item 
class \textbf{ json\+\_\+sax\+\_\+acceptor}
\item 
class \textbf{ json\+\_\+sax\+\_\+dom\+\_\+callback\+\_\+parser}
\item 
class \textbf{ json\+\_\+sax\+\_\+dom\+\_\+parser}
\begin{DoxyCompactList}\small\item\em SAX implementation to create a JSON value from SAX events. \end{DoxyCompactList}\item 
class \textbf{ lexer}
\begin{DoxyCompactList}\small\item\em lexical analysis \end{DoxyCompactList}\item 
class \textbf{ lexer\+\_\+base}
\item 
struct \textbf{ make\+\_\+index\+\_\+sequence}
\item 
struct \textbf{ make\+\_\+index\+\_\+sequence$<$ 0 $>$}
\item 
struct \textbf{ make\+\_\+index\+\_\+sequence$<$ 1 $>$}
\item 
struct \textbf{ make\+\_\+void}
\item 
struct \textbf{ merge\+\_\+and\+\_\+renumber}
\item 
struct \textbf{ merge\+\_\+and\+\_\+renumber$<$ index\+\_\+sequence$<$ I1... $>$, index\+\_\+sequence$<$ I2... $>$ $>$}
\item 
struct \textbf{ nonesuch}
\item 
class \textbf{ other\+\_\+error}
\begin{DoxyCompactList}\small\item\em exception indicating other library errors \end{DoxyCompactList}\item 
class \textbf{ out\+\_\+of\+\_\+range}
\begin{DoxyCompactList}\small\item\em exception indicating access out of the defined range \end{DoxyCompactList}\item 
class \textbf{ output\+\_\+adapter}
\item 
struct \textbf{ output\+\_\+adapter\+\_\+protocol}
\begin{DoxyCompactList}\small\item\em abstract output adapter interface \end{DoxyCompactList}\item 
class \textbf{ output\+\_\+stream\+\_\+adapter}
\begin{DoxyCompactList}\small\item\em output adapter for output streams \end{DoxyCompactList}\item 
class \textbf{ output\+\_\+string\+\_\+adapter}
\begin{DoxyCompactList}\small\item\em output adapter for basic\+\_\+string \end{DoxyCompactList}\item 
class \textbf{ output\+\_\+vector\+\_\+adapter}
\begin{DoxyCompactList}\small\item\em output adapter for byte vectors \end{DoxyCompactList}\item 
class \textbf{ parse\+\_\+error}
\begin{DoxyCompactList}\small\item\em exception indicating a parse error \end{DoxyCompactList}\item 
class \textbf{ parser}
\begin{DoxyCompactList}\small\item\em syntax analysis \end{DoxyCompactList}\item 
struct \textbf{ position\+\_\+t}
\begin{DoxyCompactList}\small\item\em struct to capture the start position of the current token \end{DoxyCompactList}\item 
class \textbf{ primitive\+\_\+iterator\+\_\+t}
\item 
struct \textbf{ priority\+\_\+tag}
\item 
struct \textbf{ priority\+\_\+tag$<$ 0 $>$}
\item 
class \textbf{ serializer}
\item 
class \textbf{ span\+\_\+input\+\_\+adapter}
\item 
struct \textbf{ static\+\_\+const}
\item 
struct \textbf{ to\+\_\+json\+\_\+fn}
\item 
class \textbf{ type\+\_\+error}
\begin{DoxyCompactList}\small\item\em exception indicating executing a member function with a wrong type \end{DoxyCompactList}\item 
class \textbf{ wide\+\_\+string\+\_\+input\+\_\+adapter}
\item 
struct \textbf{ wide\+\_\+string\+\_\+input\+\_\+helper}
\item 
struct \textbf{ wide\+\_\+string\+\_\+input\+\_\+helper$<$ Base\+Input\+Adapter, 2 $>$}
\item 
struct \textbf{ wide\+\_\+string\+\_\+input\+\_\+helper$<$ Base\+Input\+Adapter, 4 $>$}
\end{DoxyCompactItemize}
\doxysubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
\mbox{\label{namespacenlohmann_1_1detail_a02bcbc878bee413f25b985ada771aa9c}} 
{\footnotesize template$<$bool B, typename T  = void$>$ }\\using {\bfseries enable\+\_\+if\+\_\+t} = typename std\+::enable\+\_\+if$<$ B, T $>$\+::type
\item 
\mbox{\label{namespacenlohmann_1_1detail_a53a082eedad9f4729fcd8fed552a21f7}} 
{\footnotesize template$<$typename T $>$ }\\using {\bfseries uncvref\+\_\+t} = typename std\+::remove\+\_\+cv$<$ typename std\+::remove\+\_\+reference$<$ T $>$\+::type $>$\+::type
\item 
\mbox{\label{namespacenlohmann_1_1detail_a24800493c6ec02ce033dcbb47b7fd28e}} 
{\footnotesize template$<$typename... Ts$>$ }\\using {\bfseries index\+\_\+sequence\+\_\+for} = \textbf{ make\+\_\+index\+\_\+sequence}$<$ sizeof...(Ts)$>$
\item 
\mbox{\label{namespacenlohmann_1_1detail_a92a167c49c6697b6ffe4f79492c705e5}} 
{\footnotesize template$<$typename ... Ts$>$ }\\using {\bfseries void\+\_\+t} = typename \textbf{ make\+\_\+void}$<$ Ts... $>$\+::type
\item 
\mbox{\label{namespacenlohmann_1_1detail_a9135fcf616d6ac6e231a86e0a055ac44}} 
{\footnotesize template$<$template$<$ class... $>$ class Op, class... Args$>$ }\\using {\bfseries is\+\_\+detected} = typename \textbf{ detector}$<$ \textbf{ nonesuch}, void, Op, Args... $>$\+::\textbf{ value\+\_\+t}
\item 
\mbox{\label{namespacenlohmann_1_1detail_a37e97a32d0b94ce5f745427e4e40204d}} 
{\footnotesize template$<$template$<$ class... $>$ class Op, class... Args$>$ }\\using {\bfseries detected\+\_\+t} = typename \textbf{ detector}$<$ \textbf{ nonesuch}, void, Op, Args... $>$\+::type
\item 
\mbox{\label{namespacenlohmann_1_1detail_a240ce21919ab08e8a6cb3a5cfa412bce}} 
{\footnotesize template$<$class Default , template$<$ class... $>$ class Op, class... Args$>$ }\\using {\bfseries detected\+\_\+or} = \textbf{ detector}$<$ Default, void, Op, Args... $>$
\item 
\mbox{\label{namespacenlohmann_1_1detail_a7ac5b8ef0363101275a2827b3b117dcf}} 
{\footnotesize template$<$class Default , template$<$ class... $>$ class Op, class... Args$>$ }\\using {\bfseries detected\+\_\+or\+\_\+t} = typename \textbf{ detected\+\_\+or}$<$ Default, Op, Args... $>$\+::type
\item 
\mbox{\label{namespacenlohmann_1_1detail_a7542b4dbac07817fd4849ecfa4619def}} 
{\footnotesize template$<$class Expected , template$<$ class... $>$ class Op, class... Args$>$ }\\using {\bfseries is\+\_\+detected\+\_\+exact} = std\+::is\+\_\+same$<$ Expected, detected\+\_\+t$<$ Op, Args... $>$ $>$
\item 
\mbox{\label{namespacenlohmann_1_1detail_a5262e531c46e357b33007060f294673b}} 
{\footnotesize template$<$class To , template$<$ class... $>$ class Op, class... Args$>$ }\\using {\bfseries is\+\_\+detected\+\_\+convertible} = std\+::is\+\_\+convertible$<$ detected\+\_\+t$<$ Op, Args... $>$, To $>$
\item 
\mbox{\label{namespacenlohmann_1_1detail_a9c1795c148875722f8482d39e0eb9364}} 
{\footnotesize template$<$typename T $>$ }\\using {\bfseries mapped\+\_\+type\+\_\+t} = typename T\+::mapped\+\_\+type
\item 
\mbox{\label{namespacenlohmann_1_1detail_a66dfe39f03b05d6b7265a0ff748d64ef}} 
{\footnotesize template$<$typename T $>$ }\\using {\bfseries key\+\_\+type\+\_\+t} = typename T\+::key\+\_\+type
\item 
\mbox{\label{namespacenlohmann_1_1detail_af91beae90c2fb0f931079b3d50a343bc}} 
{\footnotesize template$<$typename T $>$ }\\using {\bfseries value\+\_\+type\+\_\+t} = typename T\+::value\+\_\+type
\item 
\mbox{\label{namespacenlohmann_1_1detail_a3603b59a17d1c5e15050743b847992f2}} 
{\footnotesize template$<$typename T $>$ }\\using {\bfseries difference\+\_\+type\+\_\+t} = typename T\+::difference\+\_\+type
\item 
\mbox{\label{namespacenlohmann_1_1detail_a26dc71e2dd9336587e56062178f9abce}} 
{\footnotesize template$<$typename T $>$ }\\using {\bfseries pointer\+\_\+t} = typename T\+::pointer
\item 
\mbox{\label{namespacenlohmann_1_1detail_a082bdafd3b4c61d9d1e92b35b8f75ee3}} 
{\footnotesize template$<$typename T $>$ }\\using {\bfseries reference\+\_\+t} = typename T\+::reference
\item 
\mbox{\label{namespacenlohmann_1_1detail_ad22d2aa3aab018050ae519f6754366e1}} 
{\footnotesize template$<$typename T $>$ }\\using {\bfseries iterator\+\_\+category\+\_\+t} = typename T\+::iterator\+\_\+category
\item 
\mbox{\label{namespacenlohmann_1_1detail_a9ff93db146174305bce1bc4c54703e11}} 
{\footnotesize template$<$typename T $>$ }\\using {\bfseries iterator\+\_\+t} = typename T\+::iterator
\item 
\mbox{\label{namespacenlohmann_1_1detail_af846b6cf2f926009ff3a7a61495ca383}} 
{\footnotesize template$<$typename T , typename... Args$>$ }\\using {\bfseries to\+\_\+json\+\_\+function} = decltype(T\+::to\+\_\+json(std\+::declval$<$ Args $>$()...))
\item 
\mbox{\label{namespacenlohmann_1_1detail_a1711ee5cef66a0523055c8d9f024f322}} 
{\footnotesize template$<$typename T , typename... Args$>$ }\\using {\bfseries from\+\_\+json\+\_\+function} = decltype(T\+::from\+\_\+json(std\+::declval$<$ Args $>$()...))
\item 
\mbox{\label{namespacenlohmann_1_1detail_ab4d22cdb6521ee3508db496dea66711e}} 
{\footnotesize template$<$typename T , typename U $>$ }\\using {\bfseries get\+\_\+template\+\_\+function} = decltype(std\+::declval$<$ T $>$().template get$<$ U $>$())
\item 
\mbox{\label{namespacenlohmann_1_1detail_abc51edd46a1d1a0ff06a19f08ceff563}} 
using {\bfseries contiguous\+\_\+bytes\+\_\+input\+\_\+adapter} = decltype(input\+\_\+adapter(std\+::declval$<$ const char $\ast$ $>$(), std\+::declval$<$ const char $\ast$ $>$()))
\item 
\mbox{\label{namespacenlohmann_1_1detail_ac1b4e524746bf8b790b2b776048b93c4}} 
{\footnotesize template$<$typename T $>$ }\\using {\bfseries null\+\_\+function\+\_\+t} = decltype(std\+::declval$<$ T \& $>$().null())
\item 
\mbox{\label{namespacenlohmann_1_1detail_a45ec87326503b8884b664a9ef23a6c99}} 
{\footnotesize template$<$typename T $>$ }\\using {\bfseries boolean\+\_\+function\+\_\+t} = decltype(std\+::declval$<$ T \& $>$().boolean(std\+::declval$<$ bool $>$()))
\item 
\mbox{\label{namespacenlohmann_1_1detail_a4a3e14a011b9ea1ff849fc6d2411e6a0}} 
{\footnotesize template$<$typename T , typename Integer $>$ }\\using {\bfseries number\+\_\+integer\+\_\+function\+\_\+t} = decltype(std\+::declval$<$ T \& $>$().number\+\_\+integer(std\+::declval$<$ Integer $>$()))
\item 
\mbox{\label{namespacenlohmann_1_1detail_a74da7b17bda76f65d276feb18209c913}} 
{\footnotesize template$<$typename T , typename Unsigned $>$ }\\using {\bfseries number\+\_\+unsigned\+\_\+function\+\_\+t} = decltype(std\+::declval$<$ T \& $>$().number\+\_\+unsigned(std\+::declval$<$ Unsigned $>$()))
\item 
\mbox{\label{namespacenlohmann_1_1detail_ad42df56e913abe26ed556e0e92f386f4}} 
{\footnotesize template$<$typename T , typename Float , typename String $>$ }\\using {\bfseries number\+\_\+float\+\_\+function\+\_\+t} = decltype(std\+::declval$<$ T \& $>$().number\+\_\+float(std\+::declval$<$ Float $>$(), std\+::declval$<$ const String \& $>$()))
\item 
\mbox{\label{namespacenlohmann_1_1detail_a27c3fc3bd42ac406f763184aa8ae4cb0}} 
{\footnotesize template$<$typename T , typename String $>$ }\\using {\bfseries string\+\_\+function\+\_\+t} = decltype(std\+::declval$<$ T \& $>$().string(std\+::declval$<$ String \& $>$()))
\item 
\mbox{\label{namespacenlohmann_1_1detail_a4948bef216c2594dae7921d9c4045455}} 
{\footnotesize template$<$typename T , typename Binary $>$ }\\using {\bfseries binary\+\_\+function\+\_\+t} = decltype(std\+::declval$<$ T \& $>$().binary(std\+::declval$<$ Binary \& $>$()))
\item 
\mbox{\label{namespacenlohmann_1_1detail_a5fff1e6dcaabd367d9b1109a5682f9d4}} 
{\footnotesize template$<$typename T $>$ }\\using {\bfseries start\+\_\+object\+\_\+function\+\_\+t} = decltype(std\+::declval$<$ T \& $>$().start\+\_\+object(std\+::declval$<$ std\+::size\+\_\+t $>$()))
\item 
\mbox{\label{namespacenlohmann_1_1detail_a44869ca9f422b260625d78e4e8121559}} 
{\footnotesize template$<$typename T , typename String $>$ }\\using {\bfseries key\+\_\+function\+\_\+t} = decltype(std\+::declval$<$ T \& $>$().key(std\+::declval$<$ String \& $>$()))
\item 
\mbox{\label{namespacenlohmann_1_1detail_af52d6d2521c386998ae940d118182ebc}} 
{\footnotesize template$<$typename T $>$ }\\using {\bfseries end\+\_\+object\+\_\+function\+\_\+t} = decltype(std\+::declval$<$ T \& $>$().end\+\_\+object())
\item 
\mbox{\label{namespacenlohmann_1_1detail_a80273cecc45765d7b2826ec931fbffdd}} 
{\footnotesize template$<$typename T $>$ }\\using {\bfseries start\+\_\+array\+\_\+function\+\_\+t} = decltype(std\+::declval$<$ T \& $>$().start\+\_\+array(std\+::declval$<$ std\+::size\+\_\+t $>$()))
\item 
\mbox{\label{namespacenlohmann_1_1detail_aec53c029383b34a72182210e58fadb79}} 
{\footnotesize template$<$typename T $>$ }\\using {\bfseries end\+\_\+array\+\_\+function\+\_\+t} = decltype(std\+::declval$<$ T \& $>$().end\+\_\+array())
\item 
\mbox{\label{namespacenlohmann_1_1detail_a264d4d58bc1fd82bcc7bf6bf73d6acad}} 
{\footnotesize template$<$typename T , typename Exception $>$ }\\using {\bfseries parse\+\_\+error\+\_\+function\+\_\+t} = decltype(std\+::declval$<$ T \& $>$().\textbf{ parse\+\_\+error}(std\+::declval$<$ std\+::size\+\_\+t $>$(), std\+::declval$<$ const std\+::string \& $>$(), std\+::declval$<$ const Exception \& $>$()))
\item 
\mbox{\label{namespacenlohmann_1_1detail_a9980144ad77e50ae944d1fe797ceec08}} 
{\footnotesize template$<$typename Basic\+Json\+Type $>$ }\\using {\bfseries parser\+\_\+callback\+\_\+t} = std\+::function$<$ bool(int depth, \textbf{ parse\+\_\+event\+\_\+t} event, Basic\+Json\+Type \&parsed)$>$
\item 
\mbox{\label{namespacenlohmann_1_1detail_a9b680ddfb58f27eb53a67229447fc556}} 
{\footnotesize template$<$typename Char\+Type $>$ }\\using \textbf{ output\+\_\+adapter\+\_\+t} = std\+::shared\+\_\+ptr$<$ \textbf{ output\+\_\+adapter\+\_\+protocol}$<$ Char\+Type $>$ $>$
\begin{DoxyCompactList}\small\item\em a type to simplify interfaces \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum class \textbf{ value\+\_\+t} \+: std\+::uint8\+\_\+t \{ \newline
\textbf{ null}
, \textbf{ object}
, \textbf{ array}
, \textbf{ string}
, \newline
\textbf{ boolean}
, \textbf{ number\+\_\+integer}
, \textbf{ number\+\_\+unsigned}
, \textbf{ number\+\_\+float}
, \newline
\textbf{ binary}
, \textbf{ discarded}
 \}
\begin{DoxyCompactList}\small\item\em the JSON type enumeration \end{DoxyCompactList}\item 
\mbox{\label{namespacenlohmann_1_1detail_aa554fc6a11519e4f347deb25a9f0db40}} 
enum class \textbf{ input\+\_\+format\+\_\+t} \{ \newline
{\bfseries json}
, {\bfseries cbor}
, {\bfseries msgpack}
, {\bfseries ubjson}
, \newline
{\bfseries bson}
 \}
\begin{DoxyCompactList}\small\item\em the supported input formats \end{DoxyCompactList}\item 
enum class \textbf{ cbor\+\_\+tag\+\_\+handler\+\_\+t} \{ \textbf{ error}
, \textbf{ ignore}
 \}
\begin{DoxyCompactList}\small\item\em how to treat CBOR tags \end{DoxyCompactList}\item 
enum class \textbf{ parse\+\_\+event\+\_\+t} \+: uint8\+\_\+t \{ \newline
\textbf{ object\+\_\+start}
, \textbf{ object\+\_\+end}
, \textbf{ array\+\_\+start}
, \textbf{ array\+\_\+end}
, \newline
\textbf{ key}
, \textbf{ value}
 \}
\item 
enum class \textbf{ error\+\_\+handler\+\_\+t} \{ \textbf{ strict}
, \textbf{ replace}
, \textbf{ ignore}
 \}
\begin{DoxyCompactList}\small\item\em how to treat decoding errors \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
bool \textbf{ operator$<$} (const \textbf{ value\+\_\+t} lhs, const \textbf{ value\+\_\+t} rhs) noexcept
\begin{DoxyCompactList}\small\item\em comparison operator for JSON types \end{DoxyCompactList}\item 
\mbox{\label{namespacenlohmann_1_1detail_a1f0395aad0fe853a4539288749d3a603}} 
{\footnotesize template$<$typename Basic\+Json\+Type $>$ }\\void {\bfseries from\+\_\+json} (const Basic\+Json\+Type \&j, typename std\+::nullptr\+\_\+t \&n)
\item 
\mbox{\label{namespacenlohmann_1_1detail_a85955b9c6dd31846e4b8e891f78614b6}} 
{\footnotesize template$<$typename Basic\+Json\+Type , typename Arithmetic\+Type , enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+arithmetic$<$ Arithmetic\+Type $>$\+::value \&\&!std\+::is\+\_\+same$<$ Arithmetic\+Type, typename Basic\+Json\+Type\+::boolean\+\_\+t $>$\+::value, int $>$  = 0$>$ }\\void {\bfseries get\+\_\+arithmetic\+\_\+value} (const Basic\+Json\+Type \&j, Arithmetic\+Type \&val)
\item 
\mbox{\label{namespacenlohmann_1_1detail_a58117f225f43d03e3a0a4a6f3d77c9d9}} 
{\footnotesize template$<$typename Basic\+Json\+Type $>$ }\\void {\bfseries from\+\_\+json} (const Basic\+Json\+Type \&j, typename Basic\+Json\+Type\+::boolean\+\_\+t \&b)
\item 
\mbox{\label{namespacenlohmann_1_1detail_ad74d89f77ada7a57eff38b43d4bf2335}} 
{\footnotesize template$<$typename Basic\+Json\+Type $>$ }\\void {\bfseries from\+\_\+json} (const Basic\+Json\+Type \&j, typename Basic\+Json\+Type\+::string\+\_\+t \&s)
\item 
\mbox{\label{namespacenlohmann_1_1detail_a2932f2bc2943dac6d51669312f4fc0f5}} 
{\footnotesize template$<$typename Basic\+Json\+Type , typename Constructible\+String\+Type , enable\+\_\+if\+\_\+t$<$ \textbf{ is\+\_\+constructible\+\_\+string\+\_\+type}$<$ Basic\+Json\+Type, Constructible\+String\+Type $>$\+::value \&\&!std\+::is\+\_\+same$<$ typename Basic\+Json\+Type\+::string\+\_\+t, Constructible\+String\+Type $>$\+::value, int $>$  = 0$>$ }\\void {\bfseries from\+\_\+json} (const Basic\+Json\+Type \&j, Constructible\+String\+Type \&s)
\item 
\mbox{\label{namespacenlohmann_1_1detail_a7cb5dd7d46a60e65f9a8e0873b3f7dd8}} 
{\footnotesize template$<$typename Basic\+Json\+Type $>$ }\\void {\bfseries from\+\_\+json} (const Basic\+Json\+Type \&j, typename Basic\+Json\+Type\+::number\+\_\+float\+\_\+t \&val)
\item 
\mbox{\label{namespacenlohmann_1_1detail_ace4d5680ba413d9fd897ccb5d9c61a1c}} 
{\footnotesize template$<$typename Basic\+Json\+Type $>$ }\\void {\bfseries from\+\_\+json} (const Basic\+Json\+Type \&j, typename Basic\+Json\+Type\+::number\+\_\+unsigned\+\_\+t \&val)
\item 
\mbox{\label{namespacenlohmann_1_1detail_a047d881e611fcac709dc318f730a1732}} 
{\footnotesize template$<$typename Basic\+Json\+Type $>$ }\\void {\bfseries from\+\_\+json} (const Basic\+Json\+Type \&j, typename Basic\+Json\+Type\+::number\+\_\+integer\+\_\+t \&val)
\item 
\mbox{\label{namespacenlohmann_1_1detail_a5440d650150d01e8015133521351b459}} 
{\footnotesize template$<$typename Basic\+Json\+Type , typename Enum\+Type , enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+enum$<$ Enum\+Type $>$\+::value, int $>$  = 0$>$ }\\void {\bfseries from\+\_\+json} (const Basic\+Json\+Type \&j, Enum\+Type \&e)
\item 
\mbox{\label{namespacenlohmann_1_1detail_a5cfb765aad92795abd7fda29d017272a}} 
{\footnotesize template$<$typename Basic\+Json\+Type , typename T , typename Allocator , enable\+\_\+if\+\_\+t$<$ \textbf{ is\+\_\+getable}$<$ Basic\+Json\+Type, T $>$\+::value, int $>$  = 0$>$ }\\void {\bfseries from\+\_\+json} (const Basic\+Json\+Type \&j, std\+::forward\+\_\+list$<$ T, Allocator $>$ \&l)
\item 
\mbox{\label{namespacenlohmann_1_1detail_a3df497b1d3977f071b488ecac1401517}} 
{\footnotesize template$<$typename Basic\+Json\+Type , typename T , enable\+\_\+if\+\_\+t$<$ \textbf{ is\+\_\+getable}$<$ Basic\+Json\+Type, T $>$\+::value, int $>$  = 0$>$ }\\void {\bfseries from\+\_\+json} (const Basic\+Json\+Type \&j, std\+::valarray$<$ T $>$ \&l)
\item 
\mbox{\label{namespacenlohmann_1_1detail_a7deb2db8eed6f1762373dde7a6595760}} 
{\footnotesize template$<$typename Basic\+Json\+Type , typename T , std\+::size\+\_\+t N$>$ }\\auto {\bfseries from\+\_\+json} (const Basic\+Json\+Type \&j, T(\&arr)[N]) -\/$>$ decltype(j.\+template get$<$ T $>$(), void())
\item 
\mbox{\label{namespacenlohmann_1_1detail_a40f7bb070a60e8ba14fffb9c117fcbd8}} 
{\footnotesize template$<$typename Basic\+Json\+Type $>$ }\\void {\bfseries from\+\_\+json\+\_\+array\+\_\+impl} (const Basic\+Json\+Type \&j, typename Basic\+Json\+Type\+::array\+\_\+t \&arr, \textbf{ priority\+\_\+tag}$<$ 3 $>$)
\item 
\mbox{\label{namespacenlohmann_1_1detail_aba0ce45ebb69fd2c7132a00f9a56b503}} 
{\footnotesize template$<$typename Basic\+Json\+Type , typename T , std\+::size\+\_\+t N$>$ }\\auto {\bfseries from\+\_\+json\+\_\+array\+\_\+impl} (const Basic\+Json\+Type \&j, std\+::array$<$ T, N $>$ \&arr, \textbf{ priority\+\_\+tag}$<$ 2 $>$) -\/$>$ decltype(j.\+template get$<$ T $>$(), void())
\item 
\mbox{\label{namespacenlohmann_1_1detail_a464e1246f3df7edea79c3f81ab701edd}} 
{\footnotesize template$<$typename Basic\+Json\+Type , typename Constructible\+Array\+Type $>$ }\\auto {\bfseries from\+\_\+json\+\_\+array\+\_\+impl} (const Basic\+Json\+Type \&j, Constructible\+Array\+Type \&arr, \textbf{ priority\+\_\+tag}$<$ 1 $>$) -\/$>$ decltype(arr.\+reserve(std\+::declval$<$ typename Constructible\+Array\+Type\+::size\+\_\+type $>$()), j.\+template get$<$ typename Constructible\+Array\+Type\+::value\+\_\+type $>$(), void())
\item 
\mbox{\label{namespacenlohmann_1_1detail_a20cf21255e75cff1ffb0869c2c545e63}} 
{\footnotesize template$<$typename Basic\+Json\+Type , typename Constructible\+Array\+Type $>$ }\\void {\bfseries from\+\_\+json\+\_\+array\+\_\+impl} (const Basic\+Json\+Type \&j, Constructible\+Array\+Type \&arr, \textbf{ priority\+\_\+tag}$<$ 0 $>$)
\item 
\mbox{\label{namespacenlohmann_1_1detail_aaa047a3e6a297a70e41fab254a3ea8b3}} 
{\footnotesize template$<$typename Basic\+Json\+Type , typename Constructible\+Array\+Type , enable\+\_\+if\+\_\+t$<$ \textbf{ is\+\_\+constructible\+\_\+array\+\_\+type}$<$ Basic\+Json\+Type, Constructible\+Array\+Type $>$\+::value \&\&!\textbf{ is\+\_\+constructible\+\_\+object\+\_\+type}$<$ Basic\+Json\+Type, Constructible\+Array\+Type $>$\+::value \&\&!\textbf{ is\+\_\+constructible\+\_\+string\+\_\+type}$<$ Basic\+Json\+Type, Constructible\+Array\+Type $>$\+::value \&\&!std\+::is\+\_\+same$<$ Constructible\+Array\+Type, typename Basic\+Json\+Type\+::binary\+\_\+t $>$\+::value \&\&!\textbf{ is\+\_\+basic\+\_\+json}$<$ Constructible\+Array\+Type $>$\+::value, int $>$  = 0$>$ }\\auto {\bfseries from\+\_\+json} (const Basic\+Json\+Type \&j, Constructible\+Array\+Type \&arr) -\/$>$ decltype(from\+\_\+json\+\_\+array\+\_\+impl(j, arr, \textbf{ priority\+\_\+tag}$<$ 3 $>$ \{\}), j.\+template get$<$ typename Constructible\+Array\+Type\+::value\+\_\+type $>$(), void())
\item 
\mbox{\label{namespacenlohmann_1_1detail_aeabc1adfeb8bcfbdf24c533380d1e773}} 
{\footnotesize template$<$typename Basic\+Json\+Type $>$ }\\void {\bfseries from\+\_\+json} (const Basic\+Json\+Type \&j, typename Basic\+Json\+Type\+::binary\+\_\+t \&bin)
\item 
\mbox{\label{namespacenlohmann_1_1detail_a5b24896e5f5db6af06d939dde4b63fe1}} 
{\footnotesize template$<$typename Basic\+Json\+Type , typename Constructible\+Object\+Type , enable\+\_\+if\+\_\+t$<$ \textbf{ is\+\_\+constructible\+\_\+object\+\_\+type}$<$ Basic\+Json\+Type, Constructible\+Object\+Type $>$\+::value, int $>$  = 0$>$ }\\void {\bfseries from\+\_\+json} (const Basic\+Json\+Type \&j, Constructible\+Object\+Type \&obj)
\item 
\mbox{\label{namespacenlohmann_1_1detail_a839b0ab50d2c9bce669068f56bc41202}} 
{\footnotesize template$<$typename Basic\+Json\+Type , typename Arithmetic\+Type , enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+arithmetic$<$ Arithmetic\+Type $>$\+::value \&\&!std\+::is\+\_\+same$<$ Arithmetic\+Type, typename Basic\+Json\+Type\+::number\+\_\+unsigned\+\_\+t $>$\+::value \&\&!std\+::is\+\_\+same$<$ Arithmetic\+Type, typename Basic\+Json\+Type\+::number\+\_\+integer\+\_\+t $>$\+::value \&\&!std\+::is\+\_\+same$<$ Arithmetic\+Type, typename Basic\+Json\+Type\+::number\+\_\+float\+\_\+t $>$\+::value \&\&!std\+::is\+\_\+same$<$ Arithmetic\+Type, typename Basic\+Json\+Type\+::boolean\+\_\+t $>$\+::value, int $>$  = 0$>$ }\\void {\bfseries from\+\_\+json} (const Basic\+Json\+Type \&j, Arithmetic\+Type \&val)
\item 
\mbox{\label{namespacenlohmann_1_1detail_aae9f9c2601074e323d49428132cc293d}} 
{\footnotesize template$<$typename Basic\+Json\+Type , typename A1 , typename A2 $>$ }\\void {\bfseries from\+\_\+json} (const Basic\+Json\+Type \&j, std\+::pair$<$ A1, A2 $>$ \&p)
\item 
\mbox{\label{namespacenlohmann_1_1detail_a28253915d9db4a0112d60eaee0422949}} 
{\footnotesize template$<$typename Basic\+Json\+Type , typename Tuple , std\+::size\+\_\+t... Idx$>$ }\\void {\bfseries from\+\_\+json\+\_\+tuple\+\_\+impl} (const Basic\+Json\+Type \&j, Tuple \&t, \textbf{ index\+\_\+sequence}$<$ Idx... $>$)
\item 
\mbox{\label{namespacenlohmann_1_1detail_a8b99ec9b29f3f20a18fc4281fb784e49}} 
{\footnotesize template$<$typename Basic\+Json\+Type , typename... Args$>$ }\\void {\bfseries from\+\_\+json} (const Basic\+Json\+Type \&j, std\+::tuple$<$ Args... $>$ \&t)
\item 
\mbox{\label{namespacenlohmann_1_1detail_ae93147a54d2740228ef16a5e6210ca3e}} 
{\footnotesize template$<$typename Basic\+Json\+Type , typename Key , typename Value , typename Compare , typename Allocator , typename  = enable\+\_\+if\+\_\+t $<$ !std\+::is\+\_\+constructible $<$                                        typename Basic\+Json\+Type\+::string\+\_\+t, Key $>$\+::value $>$$>$ }\\void {\bfseries from\+\_\+json} (const Basic\+Json\+Type \&j, std\+::map$<$ Key, Value, Compare, Allocator $>$ \&m)
\item 
\mbox{\label{namespacenlohmann_1_1detail_aef5c8ea108f4d2b03fb4a635617510de}} 
{\footnotesize template$<$typename Basic\+Json\+Type , typename Key , typename Value , typename Hash , typename Key\+Equal , typename Allocator , typename  = enable\+\_\+if\+\_\+t $<$ !std\+::is\+\_\+constructible $<$                                        typename Basic\+Json\+Type\+::string\+\_\+t, Key $>$\+::value $>$$>$ }\\void {\bfseries from\+\_\+json} (const Basic\+Json\+Type \&j, std\+::unordered\+\_\+map$<$ Key, Value, Hash, Key\+Equal, Allocator $>$ \&m)
\item 
\mbox{\label{namespacenlohmann_1_1detail_a3c45286b0a2f15ea0a756cb87a76cf9b}} 
{\footnotesize template$<$typename string\+\_\+type $>$ }\\void {\bfseries int\+\_\+to\+\_\+string} (string\+\_\+type \&target, std\+::size\+\_\+t value)
\item 
\mbox{\label{namespacenlohmann_1_1detail_acc422c11342b31368f610b6f96fcedc6}} 
{\footnotesize template$<$std\+::size\+\_\+t N, typename Iterator\+Type , enable\+\_\+if\+\_\+t$<$ N==0, int $>$  = 0$>$ }\\auto {\bfseries get} (const \textbf{ nlohmann\+::detail\+::iteration\+\_\+proxy\+\_\+value}$<$ Iterator\+Type $>$ \&i) -\/$>$ decltype(i.\+key())
\item 
\mbox{\label{namespacenlohmann_1_1detail_a1a804b98cbe89b7e44b698f2ca860490}} 
{\footnotesize template$<$typename Basic\+Json\+Type , typename T , enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+same$<$ T, typename Basic\+Json\+Type\+::boolean\+\_\+t $>$\+::value, int $>$  = 0$>$ }\\void {\bfseries to\+\_\+json} (Basic\+Json\+Type \&j, T b) noexcept
\item 
\mbox{\label{namespacenlohmann_1_1detail_a7356ed05cdbbb080cee80e1211e1c6c9}} 
{\footnotesize template$<$typename Basic\+Json\+Type , typename Compatible\+String , enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+constructible$<$ typename Basic\+Json\+Type\+::string\+\_\+t, Compatible\+String $>$\+::value, int $>$  = 0$>$ }\\void {\bfseries to\+\_\+json} (Basic\+Json\+Type \&j, const Compatible\+String \&s)
\item 
\mbox{\label{namespacenlohmann_1_1detail_a4aa1ca6b7c61bf19d1f30ea5b669f68e}} 
{\footnotesize template$<$typename Basic\+Json\+Type $>$ }\\void {\bfseries to\+\_\+json} (Basic\+Json\+Type \&j, typename Basic\+Json\+Type\+::string\+\_\+t \&\&s)
\item 
\mbox{\label{namespacenlohmann_1_1detail_a22bffdc8bc7e43af380ba2050696b230}} 
{\footnotesize template$<$typename Basic\+Json\+Type , typename Float\+Type , enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+floating\+\_\+point$<$ Float\+Type $>$\+::value, int $>$  = 0$>$ }\\void {\bfseries to\+\_\+json} (Basic\+Json\+Type \&j, Float\+Type val) noexcept
\item 
\mbox{\label{namespacenlohmann_1_1detail_ae5fd66b5517b3b5a6c6b9fd9f29ba8dc}} 
{\footnotesize template$<$typename Basic\+Json\+Type , typename Compatible\+Number\+Unsigned\+Type , enable\+\_\+if\+\_\+t$<$ \textbf{ is\+\_\+compatible\+\_\+integer\+\_\+type}$<$ typename Basic\+Json\+Type\+::number\+\_\+unsigned\+\_\+t, Compatible\+Number\+Unsigned\+Type $>$\+::value, int $>$  = 0$>$ }\\void {\bfseries to\+\_\+json} (Basic\+Json\+Type \&j, Compatible\+Number\+Unsigned\+Type val) noexcept
\item 
\mbox{\label{namespacenlohmann_1_1detail_a91fe576be579c8c2fdd14610605c6dd2}} 
{\footnotesize template$<$typename Basic\+Json\+Type , typename Compatible\+Number\+Integer\+Type , enable\+\_\+if\+\_\+t$<$ \textbf{ is\+\_\+compatible\+\_\+integer\+\_\+type}$<$ typename Basic\+Json\+Type\+::number\+\_\+integer\+\_\+t, Compatible\+Number\+Integer\+Type $>$\+::value, int $>$  = 0$>$ }\\void {\bfseries to\+\_\+json} (Basic\+Json\+Type \&j, Compatible\+Number\+Integer\+Type val) noexcept
\item 
\mbox{\label{namespacenlohmann_1_1detail_a0c8b159dba71981d6c555d284cf6e2bf}} 
{\footnotesize template$<$typename Basic\+Json\+Type , typename Enum\+Type , enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+enum$<$ Enum\+Type $>$\+::value, int $>$  = 0$>$ }\\void {\bfseries to\+\_\+json} (Basic\+Json\+Type \&j, Enum\+Type e) noexcept
\item 
\mbox{\label{namespacenlohmann_1_1detail_aeca6fb5fede5ed1e12a4420d98a5692b}} 
{\footnotesize template$<$typename Basic\+Json\+Type $>$ }\\void {\bfseries to\+\_\+json} (Basic\+Json\+Type \&j, const std\+::vector$<$ bool $>$ \&e)
\item 
\mbox{\label{namespacenlohmann_1_1detail_a3afebc132c5ff83f9cd160e52030fdfd}} 
{\footnotesize template$<$typename Basic\+Json\+Type , typename Compatible\+Array\+Type , enable\+\_\+if\+\_\+t$<$ \textbf{ is\+\_\+compatible\+\_\+array\+\_\+type}$<$ Basic\+Json\+Type, Compatible\+Array\+Type $>$\+::value \&\&!\textbf{ is\+\_\+compatible\+\_\+object\+\_\+type}$<$ Basic\+Json\+Type, Compatible\+Array\+Type $>$\+::value \&\&!\textbf{ is\+\_\+compatible\+\_\+string\+\_\+type}$<$ Basic\+Json\+Type, Compatible\+Array\+Type $>$\+::value \&\&!std\+::is\+\_\+same$<$ typename Basic\+Json\+Type\+::binary\+\_\+t, Compatible\+Array\+Type $>$\+::value \&\&!\textbf{ is\+\_\+basic\+\_\+json}$<$ Compatible\+Array\+Type $>$\+::value, int $>$  = 0$>$ }\\void {\bfseries to\+\_\+json} (Basic\+Json\+Type \&j, const Compatible\+Array\+Type \&arr)
\item 
\mbox{\label{namespacenlohmann_1_1detail_a22191081208b226e3875e1118107c281}} 
{\footnotesize template$<$typename Basic\+Json\+Type $>$ }\\void {\bfseries to\+\_\+json} (Basic\+Json\+Type \&j, const typename Basic\+Json\+Type\+::binary\+\_\+t \&bin)
\item 
\mbox{\label{namespacenlohmann_1_1detail_a7f7c7b9760161b774cdc0b4b838fae64}} 
{\footnotesize template$<$typename Basic\+Json\+Type , typename T , enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+convertible$<$ T, Basic\+Json\+Type $>$\+::value, int $>$  = 0$>$ }\\void {\bfseries to\+\_\+json} (Basic\+Json\+Type \&j, const std\+::valarray$<$ T $>$ \&arr)
\item 
\mbox{\label{namespacenlohmann_1_1detail_aa0fd1b5788e9ba37e31da43dda738cb5}} 
{\footnotesize template$<$typename Basic\+Json\+Type $>$ }\\void {\bfseries to\+\_\+json} (Basic\+Json\+Type \&j, typename Basic\+Json\+Type\+::array\+\_\+t \&\&arr)
\item 
\mbox{\label{namespacenlohmann_1_1detail_a24c9c12f3839c94e09532f08de85e949}} 
{\footnotesize template$<$typename Basic\+Json\+Type , typename Compatible\+Object\+Type , enable\+\_\+if\+\_\+t$<$ \textbf{ is\+\_\+compatible\+\_\+object\+\_\+type}$<$ Basic\+Json\+Type, Compatible\+Object\+Type $>$\+::value \&\&!\textbf{ is\+\_\+basic\+\_\+json}$<$ Compatible\+Object\+Type $>$\+::value, int $>$  = 0$>$ }\\void {\bfseries to\+\_\+json} (Basic\+Json\+Type \&j, const Compatible\+Object\+Type \&obj)
\item 
\mbox{\label{namespacenlohmann_1_1detail_ac9f7a5542851c61d93740148eaec509f}} 
{\footnotesize template$<$typename Basic\+Json\+Type $>$ }\\void {\bfseries to\+\_\+json} (Basic\+Json\+Type \&j, typename Basic\+Json\+Type\+::object\+\_\+t \&\&obj)
\item 
\mbox{\label{namespacenlohmann_1_1detail_a20ea5175c8999fc8b673e46b892f71f6}} 
{\footnotesize template$<$typename Basic\+Json\+Type , typename T , std\+::size\+\_\+t N, enable\+\_\+if\+\_\+t$<$ !std\+::is\+\_\+constructible$<$ typename Basic\+Json\+Type\+::string\+\_\+t, const T(\&)[N]$>$\+::value, int $>$  = 0$>$ }\\void {\bfseries to\+\_\+json} (Basic\+Json\+Type \&j, const T(\&arr)[N])
\item 
\mbox{\label{namespacenlohmann_1_1detail_ab64eeb55b44db44eb8e9070229eb97df}} 
{\footnotesize template$<$typename Basic\+Json\+Type , typename T1 , typename T2 , enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+constructible$<$ Basic\+Json\+Type, T1 $>$\+::value \&\&std\+::is\+\_\+constructible$<$ Basic\+Json\+Type, T2 $>$\+::value, int $>$  = 0$>$ }\\void {\bfseries to\+\_\+json} (Basic\+Json\+Type \&j, const std\+::pair$<$ T1, T2 $>$ \&p)
\item 
\mbox{\label{namespacenlohmann_1_1detail_aaa77b0c9745130b77733a92a1a2e82ec}} 
{\footnotesize template$<$typename Basic\+Json\+Type , typename T , enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+same$<$ T, \textbf{ iteration\+\_\+proxy\+\_\+value}$<$ typename Basic\+Json\+Type\+::iterator $>$$>$\+::value, int $>$  = 0$>$ }\\void {\bfseries to\+\_\+json} (Basic\+Json\+Type \&j, const T \&b)
\item 
\mbox{\label{namespacenlohmann_1_1detail_a510dfa15b01e9a8afe31600a27b28199}} 
{\footnotesize template$<$typename Basic\+Json\+Type , typename Tuple , std\+::size\+\_\+t... Idx$>$ }\\void {\bfseries to\+\_\+json\+\_\+tuple\+\_\+impl} (Basic\+Json\+Type \&j, const Tuple \&t, \textbf{ index\+\_\+sequence}$<$ Idx... $>$)
\item 
\mbox{\label{namespacenlohmann_1_1detail_a66eb4d912b6f872d6983f7d0826f32c6}} 
std\+::size\+\_\+t {\bfseries combine} (std\+::size\+\_\+t seed, std\+::size\+\_\+t h) noexcept
\item 
{\footnotesize template$<$typename Basic\+Json\+Type $>$ }\\std\+::size\+\_\+t \textbf{ hash} (const Basic\+Json\+Type \&j)
\begin{DoxyCompactList}\small\item\em hash a JSON value \end{DoxyCompactList}\item 
\mbox{\label{namespacenlohmann_1_1detail_ad11a087dbe66eade5af4056aef9600bf}} 
{\footnotesize template$<$typename Iterator\+Type $>$ }\\\textbf{ iterator\+\_\+input\+\_\+adapter\+\_\+factory}$<$ Iterator\+Type $>$\+::adapter\+\_\+type {\bfseries input\+\_\+adapter} (Iterator\+Type first, Iterator\+Type last)
\item 
\mbox{\label{namespacenlohmann_1_1detail_a8487ca95646f8368f70e279e9bf63396}} 
{\footnotesize template$<$typename Container\+Type $>$ }\\auto {\bfseries input\+\_\+adapter} (const Container\+Type \&container) -\/$>$ decltype(input\+\_\+adapter(begin(container), end(container)))
\item 
\mbox{\label{namespacenlohmann_1_1detail_a520988513cac994a1dfd16b5859a1ca6}} 
\textbf{ file\+\_\+input\+\_\+adapter} {\bfseries input\+\_\+adapter} (std\+::\+FILE $\ast$file)
\item 
\mbox{\label{namespacenlohmann_1_1detail_af9fa97bf92767dc7f9dfe1abdfb1c6ce}} 
\textbf{ input\+\_\+stream\+\_\+adapter} {\bfseries input\+\_\+adapter} (std\+::istream \&stream)
\item 
\mbox{\label{namespacenlohmann_1_1detail_aaf150c2591ecac4e821e9036ef847ef8}} 
\textbf{ input\+\_\+stream\+\_\+adapter} {\bfseries input\+\_\+adapter} (std\+::istream \&\&stream)
\item 
\mbox{\label{namespacenlohmann_1_1detail_a690f7e555056ce490bd47dd5cdf9b48d}} 
{\footnotesize template$<$typename CharT , typename std\+::enable\+\_\+if$<$ std\+::is\+\_\+pointer$<$ CharT $>$\+::value \&\&!std\+::is\+\_\+array$<$ CharT $>$\+::value \&\&std\+::is\+\_\+integral$<$ typename std\+::remove\+\_\+pointer$<$ CharT $>$\+::type $>$\+::value \&\&sizeof(typename std\+::remove\+\_\+pointer$<$ CharT $>$\+::type)==1, int $>$\+::type  = 0$>$ }\\contiguous\+\_\+bytes\+\_\+input\+\_\+adapter {\bfseries input\+\_\+adapter} (CharT b)
\item 
\mbox{\label{namespacenlohmann_1_1detail_a7908f7aa06f20e6083619d1d4b4eb769}} 
{\footnotesize template$<$typename T , std\+::size\+\_\+t N$>$ }\\auto {\bfseries input\+\_\+adapter} (T(\&array)[N]) -\/$>$ decltype(input\+\_\+adapter(array, array+N))
\item 
{\footnotesize template$<$typename Float\+Type $>$ }\\JSON\+\_\+\+HEDLEY\+\_\+\+RETURNS\+\_\+\+NON\+\_\+\+NULL char $\ast$ \textbf{ to\+\_\+chars} (char $\ast$first, const char $\ast$last, Float\+Type value)
\begin{DoxyCompactList}\small\item\em generates a decimal representation of the floating-\/point number value in [first, last). \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
detail namespace with internal helper functions 

This namespace collects functions that should not be exposed, implementations of some \doxyref{basic\+\_\+json}{p.}{classnlohmann_1_1basic__json} methods, and meta-\/programming helpers.

\begin{DoxySince}{Since}
version 2.\+1.\+0 
\end{DoxySince}


\doxysubsection{Enumeration Type Documentation}
\mbox{\label{namespacenlohmann_1_1detail_a58bb1ef1a9ad287a9cfaf1855784d9ac}} 
\index{nlohmann::detail@{nlohmann::detail}!cbor\_tag\_handler\_t@{cbor\_tag\_handler\_t}}
\index{cbor\_tag\_handler\_t@{cbor\_tag\_handler\_t}!nlohmann::detail@{nlohmann::detail}}
\doxysubsubsection{cbor\_tag\_handler\_t}
{\footnotesize\ttfamily enum \textbf{ nlohmann\+::detail\+::cbor\+\_\+tag\+\_\+handler\+\_\+t}\hspace{0.3cm}{\ttfamily [strong]}}



how to treat CBOR tags 

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{error@{error}!nlohmann::detail@{nlohmann::detail}}\index{nlohmann::detail@{nlohmann::detail}!error@{error}}}\mbox{\label{namespacenlohmann_1_1detail_a58bb1ef1a9ad287a9cfaf1855784d9acacb5e100e5a9a3e7f6d1fd97512215282}} 
error&throw a \doxyref{parse\+\_\+error}{p.}{classnlohmann_1_1detail_1_1parse__error} exception in case of a tag \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{ignore@{ignore}!nlohmann::detail@{nlohmann::detail}}\index{nlohmann::detail@{nlohmann::detail}!ignore@{ignore}}}\mbox{\label{namespacenlohmann_1_1detail_a58bb1ef1a9ad287a9cfaf1855784d9aca567bc1d268f135496de3d5b946b691f3}} 
ignore&ignore tags \\
\hline

\end{DoxyEnumFields}
\mbox{\label{namespacenlohmann_1_1detail_a5a76b60b26dc8c47256a996d18d967df}} 
\index{nlohmann::detail@{nlohmann::detail}!error\_handler\_t@{error\_handler\_t}}
\index{error\_handler\_t@{error\_handler\_t}!nlohmann::detail@{nlohmann::detail}}
\doxysubsubsection{error\_handler\_t}
{\footnotesize\ttfamily enum \textbf{ nlohmann\+::detail\+::error\+\_\+handler\+\_\+t}\hspace{0.3cm}{\ttfamily [strong]}}



how to treat decoding errors 

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{strict@{strict}!nlohmann::detail@{nlohmann::detail}}\index{nlohmann::detail@{nlohmann::detail}!strict@{strict}}}\mbox{\label{namespacenlohmann_1_1detail_a5a76b60b26dc8c47256a996d18d967dfa2133fd717402a7966ee88d06f9e0b792}} 
strict&throw a \doxyref{type\+\_\+error}{p.}{classnlohmann_1_1detail_1_1type__error} exception in case of invalid UTF-\/8 \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{replace@{replace}!nlohmann::detail@{nlohmann::detail}}\index{nlohmann::detail@{nlohmann::detail}!replace@{replace}}}\mbox{\label{namespacenlohmann_1_1detail_a5a76b60b26dc8c47256a996d18d967dfa9dde360102c103867bd2f45872f1129c}} 
replace&replace invalid UTF-\/8 sequences with U+\+FFFD \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{ignore@{ignore}!nlohmann::detail@{nlohmann::detail}}\index{nlohmann::detail@{nlohmann::detail}!ignore@{ignore}}}\mbox{\label{namespacenlohmann_1_1detail_a5a76b60b26dc8c47256a996d18d967dfa567bc1d268f135496de3d5b946b691f3}} 
ignore&ignore invalid UTF-\/8 sequences \\
\hline

\end{DoxyEnumFields}
\mbox{\label{namespacenlohmann_1_1detail_a2fb6dae6578e06ae73ca0d7cc8512b1a}} 
\index{nlohmann::detail@{nlohmann::detail}!parse\_event\_t@{parse\_event\_t}}
\index{parse\_event\_t@{parse\_event\_t}!nlohmann::detail@{nlohmann::detail}}
\doxysubsubsection{parse\_event\_t}
{\footnotesize\ttfamily enum \textbf{ nlohmann\+::detail\+::parse\+\_\+event\+\_\+t} \+: uint8\+\_\+t\hspace{0.3cm}{\ttfamily [strong]}}

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{object\_start@{object\_start}!nlohmann::detail@{nlohmann::detail}}\index{nlohmann::detail@{nlohmann::detail}!object\_start@{object\_start}}}\mbox{\label{namespacenlohmann_1_1detail_a2fb6dae6578e06ae73ca0d7cc8512b1aae73f17027cb0acbb537f29d0a6944b26}} 
object\+\_\+start&the parser read {\ttfamily \{} and started to process a JSON object \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{object\_end@{object\_end}!nlohmann::detail@{nlohmann::detail}}\index{nlohmann::detail@{nlohmann::detail}!object\_end@{object\_end}}}\mbox{\label{namespacenlohmann_1_1detail_a2fb6dae6578e06ae73ca0d7cc8512b1aaf63e2a2468a37aa4f394fcc3bcb8249c}} 
object\+\_\+end&the parser read {\ttfamily \}} and finished processing a JSON object \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{array\_start@{array\_start}!nlohmann::detail@{nlohmann::detail}}\index{nlohmann::detail@{nlohmann::detail}!array\_start@{array\_start}}}\mbox{\label{namespacenlohmann_1_1detail_a2fb6dae6578e06ae73ca0d7cc8512b1aaa4388a3d92419edbb1c6efd4d52461f3}} 
array\+\_\+start&the parser read {\ttfamily [} and started to process a JSON array \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{array\_end@{array\_end}!nlohmann::detail@{nlohmann::detail}}\index{nlohmann::detail@{nlohmann::detail}!array\_end@{array\_end}}}\mbox{\label{namespacenlohmann_1_1detail_a2fb6dae6578e06ae73ca0d7cc8512b1aa49642fb732aa2e112188fba1f9d3ef7f}} 
array\+\_\+end&the parser read {\ttfamily ]} and finished processing a JSON array \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{key@{key}!nlohmann::detail@{nlohmann::detail}}\index{nlohmann::detail@{nlohmann::detail}!key@{key}}}\mbox{\label{namespacenlohmann_1_1detail_a2fb6dae6578e06ae73ca0d7cc8512b1aa3c6e0b8a9c15224a8228b9a98ca1531d}} 
key&the parser read a key of a value in an object \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{value@{value}!nlohmann::detail@{nlohmann::detail}}\index{nlohmann::detail@{nlohmann::detail}!value@{value}}}\mbox{\label{namespacenlohmann_1_1detail_a2fb6dae6578e06ae73ca0d7cc8512b1aa2063c1608d6e0baf80249c42e2be5804}} 
value&the parser finished reading a JSON value \\
\hline

\end{DoxyEnumFields}
\mbox{\label{namespacenlohmann_1_1detail_a1ed8fc6239da25abcaf681d30ace4985}} 
\index{nlohmann::detail@{nlohmann::detail}!value\_t@{value\_t}}
\index{value\_t@{value\_t}!nlohmann::detail@{nlohmann::detail}}
\doxysubsubsection{value\_t}
{\footnotesize\ttfamily enum \textbf{ nlohmann\+::detail\+::value\+\_\+t} \+: std\+::uint8\+\_\+t\hspace{0.3cm}{\ttfamily [strong]}}



the JSON type enumeration 

This enumeration collects the different JSON types. It is internally used to distinguish the stored values, and the functions \doxyref{basic\+\_\+json\+::is\+\_\+null()}{p.}{classnlohmann_1_1basic__json_aedc7afad96292b5ab61a2e0ad3067f5f}, \doxyref{basic\+\_\+json\+::is\+\_\+object()}{p.}{classnlohmann_1_1basic__json_a57e8411a770a6263d6d8f2116c37f3aa}, \doxyref{basic\+\_\+json\+::is\+\_\+array()}{p.}{classnlohmann_1_1basic__json_ab5b70d60a636b9c5e10f6c8caac60b9e}, \doxyref{basic\+\_\+json\+::is\+\_\+string()}{p.}{classnlohmann_1_1basic__json_ab303d17366c26fca12242c7f8def1bb7}, \doxyref{basic\+\_\+json\+::is\+\_\+boolean()}{p.}{classnlohmann_1_1basic__json_a911b11e855e685fa59ea1d111490b36b}, \doxyref{basic\+\_\+json\+::is\+\_\+number()}{p.}{classnlohmann_1_1basic__json_abd47ac8eba63833152795280f75b5851} (with \doxyref{basic\+\_\+json\+::is\+\_\+number\+\_\+integer()}{p.}{classnlohmann_1_1basic__json_ac4b4acf2c0ad075c0dc125a65c102362}, \doxyref{basic\+\_\+json\+::is\+\_\+number\+\_\+unsigned()}{p.}{classnlohmann_1_1basic__json_a5493f2ed1e07b0ece428bd5a47e2fb95}, and \doxyref{basic\+\_\+json\+::is\+\_\+number\+\_\+float()}{p.}{classnlohmann_1_1basic__json_a116cdb9300b56519fc9cf756609296cb}), \doxyref{basic\+\_\+json\+::is\+\_\+discarded()}{p.}{classnlohmann_1_1basic__json_aecaaa0613d3f3a5b49b34b02afc5f85d}, \doxyref{basic\+\_\+json\+::is\+\_\+primitive()}{p.}{classnlohmann_1_1basic__json_a548d2d4013da24e7d7510d90febc80c4}, and \doxyref{basic\+\_\+json\+::is\+\_\+structured()}{p.}{classnlohmann_1_1basic__json_a4e05a7d5deec758f1d830741b68b4249} rely on it.

\begin{DoxyNote}{Note}
There are three enumeration entries (number\+\_\+integer, number\+\_\+unsigned, and number\+\_\+float), because the library distinguishes these three types for numbers\+: \doxyref{basic\+\_\+json\+::number\+\_\+unsigned\+\_\+t}{p.}{classnlohmann_1_1basic__json_ae09af9c23351b7245d9be4d1b2035fef} is used for unsigned integers, \doxyref{basic\+\_\+json\+::number\+\_\+integer\+\_\+t}{p.}{classnlohmann_1_1basic__json_a11e390944da90db83089eb2426a749d3} is used for signed integers, and \doxyref{basic\+\_\+json\+::number\+\_\+float\+\_\+t}{p.}{classnlohmann_1_1basic__json_a5b8abaebd922d82d69756327c0c347e6} is used for floating-\/point numbers or to approximate integers which do not fit in the limits of their respective type.
\end{DoxyNote}
\begin{DoxySeeAlso}{See also}
\doxyref{basic\+\_\+json\+::basic\+\_\+json(const value\+\_\+t value\+\_\+type)}{p.}{classnlohmann_1_1basic__json_a19734fbc9c97d536832892ddacd6b62a} -- create a JSON value with the default value for a given type
\end{DoxySeeAlso}
\begin{DoxySince}{Since}
version 1.\+0.\+0 
\end{DoxySince}
\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{null@{null}!nlohmann::detail@{nlohmann::detail}}\index{nlohmann::detail@{nlohmann::detail}!null@{null}}}\mbox{\label{namespacenlohmann_1_1detail_a1ed8fc6239da25abcaf681d30ace4985a37a6259cc0c1dae299a7866489dff0bd}} 
null&null value \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{object@{object}!nlohmann::detail@{nlohmann::detail}}\index{nlohmann::detail@{nlohmann::detail}!object@{object}}}\mbox{\label{namespacenlohmann_1_1detail_a1ed8fc6239da25abcaf681d30ace4985aa8cfde6331bd59eb2ac96f8911c4b666}} 
object&object (unordered set of name/value pairs) \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{array@{array}!nlohmann::detail@{nlohmann::detail}}\index{nlohmann::detail@{nlohmann::detail}!array@{array}}}\mbox{\label{namespacenlohmann_1_1detail_a1ed8fc6239da25abcaf681d30ace4985af1f713c9e000f5d3f280adbd124df4f5}} 
array&array (ordered collection of values) \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{string@{string}!nlohmann::detail@{nlohmann::detail}}\index{nlohmann::detail@{nlohmann::detail}!string@{string}}}\mbox{\label{namespacenlohmann_1_1detail_a1ed8fc6239da25abcaf681d30ace4985ab45cffe084dd3d20d928bee85e7b0f21}} 
string&string value \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{boolean@{boolean}!nlohmann::detail@{nlohmann::detail}}\index{nlohmann::detail@{nlohmann::detail}!boolean@{boolean}}}\mbox{\label{namespacenlohmann_1_1detail_a1ed8fc6239da25abcaf681d30ace4985a84e2c64f38f78ba3ea5c905ab5a2da27}} 
boolean&boolean value \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{number\_integer@{number\_integer}!nlohmann::detail@{nlohmann::detail}}\index{nlohmann::detail@{nlohmann::detail}!number\_integer@{number\_integer}}}\mbox{\label{namespacenlohmann_1_1detail_a1ed8fc6239da25abcaf681d30ace4985a5763da164f8659d94a56e29df64b4bcc}} 
number\+\_\+integer&number value (signed integer) \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{number\_unsigned@{number\_unsigned}!nlohmann::detail@{nlohmann::detail}}\index{nlohmann::detail@{nlohmann::detail}!number\_unsigned@{number\_unsigned}}}\mbox{\label{namespacenlohmann_1_1detail_a1ed8fc6239da25abcaf681d30ace4985adce7cc8ec29055c4158828921f2f265e}} 
number\+\_\+unsigned&number value (unsigned integer) \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{number\_float@{number\_float}!nlohmann::detail@{nlohmann::detail}}\index{nlohmann::detail@{nlohmann::detail}!number\_float@{number\_float}}}\mbox{\label{namespacenlohmann_1_1detail_a1ed8fc6239da25abcaf681d30ace4985ad9966ecb59667235a57b4b999a649eef}} 
number\+\_\+float&number value (floating-\/point) \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{binary@{binary}!nlohmann::detail@{nlohmann::detail}}\index{nlohmann::detail@{nlohmann::detail}!binary@{binary}}}\mbox{\label{namespacenlohmann_1_1detail_a1ed8fc6239da25abcaf681d30ace4985a9d7183f16acce70658f686ae7f1a4d20}} 
binary&binary array (ordered collection of bytes) \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{discarded@{discarded}!nlohmann::detail@{nlohmann::detail}}\index{nlohmann::detail@{nlohmann::detail}!discarded@{discarded}}}\mbox{\label{namespacenlohmann_1_1detail_a1ed8fc6239da25abcaf681d30ace4985a94708897ec9db8647dfe695714c98e46}} 
discarded&discarded by the parser callback function \\
\hline

\end{DoxyEnumFields}


\doxysubsection{Function Documentation}
\mbox{\label{namespacenlohmann_1_1detail_a679e5e522ac6afa5d5923292fab450b8}} 
\index{nlohmann::detail@{nlohmann::detail}!hash@{hash}}
\index{hash@{hash}!nlohmann::detail@{nlohmann::detail}}
\doxysubsubsection{hash()}
{\footnotesize\ttfamily template$<$typename Basic\+Json\+Type $>$ \\
std\+::size\+\_\+t nlohmann\+::detail\+::hash (\begin{DoxyParamCaption}\item[{const Basic\+Json\+Type \&}]{j }\end{DoxyParamCaption})}



hash a JSON value 

The hash function tries to rely on std\+::hash where possible. Furthermore, the type of the JSON value is taken into account to have different hash values for null, 0, 0U, and false, etc.


\begin{DoxyTemplParams}{Template Parameters}
{\em Basic\+Json\+Type} & \doxyref{basic\+\_\+json}{p.}{classnlohmann_1_1basic__json} specialization \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em j} & JSON value to hash \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
hash value of j 
\end{DoxyReturn}
\mbox{\label{namespacenlohmann_1_1detail_a09169efff3bd1771fff29bd92cea19e0}} 
\index{nlohmann::detail@{nlohmann::detail}!operator$<$@{operator$<$}}
\index{operator$<$@{operator$<$}!nlohmann::detail@{nlohmann::detail}}
\doxysubsubsection{operator$<$()}
{\footnotesize\ttfamily bool nlohmann\+::detail\+::operator$<$ (\begin{DoxyParamCaption}\item[{const \textbf{ value\+\_\+t}}]{lhs,  }\item[{const \textbf{ value\+\_\+t}}]{rhs }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



comparison operator for JSON types 

Returns an ordering that is similar to Python\+:
\begin{DoxyItemize}
\item order\+: null $<$ boolean $<$ number $<$ object $<$ array $<$ string $<$ binary
\item furthermore, each type is not smaller than itself
\item discarded values are not comparable
\item binary is represented as a b\char`\"{}\char`\"{} string in python and directly comparable to a string; however, making a binary array directly comparable with a string would be surprising behavior in a JSON file.
\end{DoxyItemize}

\begin{DoxySince}{Since}
version 1.\+0.\+0 
\end{DoxySince}
\mbox{\label{namespacenlohmann_1_1detail_a6cca370ac6c99294dbe4fe24716a57dd}} 
\index{nlohmann::detail@{nlohmann::detail}!to\_chars@{to\_chars}}
\index{to\_chars@{to\_chars}!nlohmann::detail@{nlohmann::detail}}
\doxysubsubsection{to\_chars()}
{\footnotesize\ttfamily template$<$typename Float\+Type $>$ \\
JSON\+\_\+\+HEDLEY\+\_\+\+RETURNS\+\_\+\+NON\+\_\+\+NULL char$\ast$ nlohmann\+::detail\+::to\+\_\+chars (\begin{DoxyParamCaption}\item[{char $\ast$}]{first,  }\item[{const char $\ast$}]{last,  }\item[{Float\+Type}]{value }\end{DoxyParamCaption})}



generates a decimal representation of the floating-\/point number value in [first, last). 

The format of the resulting decimal representation is similar to printf\textquotesingle{}s g format. Returns an iterator pointing past-\/the-\/end of the decimal representation.

\begin{DoxyNote}{Note}
The input number must be finite, i.\+e. NaN\textquotesingle{}s and Inf\textquotesingle{}s are not supported. 

The buffer must be large enough. 

The result is NOT null-\/terminated. 
\end{DoxyNote}
